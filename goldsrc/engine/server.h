/*
 * This file is part of OGS Engine
 * Copyright (C) 1996-1997 Id Software, Inc.
 * Copyright (C) 2018-2024 BlackPhrase
 *
 * OGS Engine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OGS Engine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with OGS Engine. If not, see <http://www.gnu.org/licenses/>.
 */

/// @file

#pragma once

#include "usercmd.h"

typedef struct
{
	double active;
	double idle;
	int count;
	int packets;

	double latched_active;
	double latched_idle;
	int latched_packets;
} svstats_t;

// MAX_CHALLENGES is made large to prevent a denial
// of service attack that could cycle all of them
// out before legitimate users connected
#define MAX_CHALLENGES 1024

typedef struct
{
	netadr_t adr;
	int challenge;
	int time;
} challenge_t;

typedef struct
{
	int spawncount; // number of servers spawned since start, used to check late spawns

	int maxclients;
	int maxclientslimit;
	struct client_s *clients;    // [maxclients]
	int serverflags;             // episode completion information
	qboolean changelevel_issued; // cleared when at SV_SpawnServer

	svstats_t stats;

	challenge_t challenges[MAX_CHALLENGES]; // to prevent invalid IPs from connecting
	
	char info[MAX_SERVERINFO_STRING]; // TODO
} server_static_t;

//=============================================================================

typedef enum { ss_loading,
	           ss_active } server_state_t;

typedef struct
{
	qboolean active; // false if only a net client

	qboolean paused;
	qboolean loadgame; // handle connections specially

	double time;

	int lastcheck; // used by PF_checkclient
	double lastchecktime;

	char name[64]; // map name
	char startspot[64];
	char modelname[64]; // maps/<name>.bsp, for model_precache[0]
	struct model_s *worldmodel;
	char *model_precache[MAX_MODELS]; // NULL terminated
	struct model_s *models[MAX_MODELS];
	char *sound_precache[MAX_SOUNDS]; // NULL terminated
	struct event_s *event_precache[MAX_EVENTS];
	struct usermsg_s *usermsgs[MAX_USERMSGS];
	char *lightstyles[MAX_LIGHTSTYLES];
	int num_edicts;
	int max_edicts;
	edict_t *edicts;      // can NOT be array indexed, because
	                      // edict_t is variable sized, but can
	                      // be used to reference the world ent
	server_state_t state; // some actions are only valid during load

	sizebuf_t datagram;
	byte datagram_buf[MAX_DATAGRAM];

	sizebuf_t reliable_datagram; // copied to all clients at end of frame
	byte reliable_datagram_buf[MAX_DATAGRAM];

	sizebuf_t signon;
	byte signon_buf[8192];
} server_t;

#define NUM_PING_TIMES 16
#define NUM_SPAWN_PARMS 16

// TODO: temp
#ifndef MAX_INFO_STRING
#define MAX_INFO_STRING 256
#endif

typedef struct
{
	// received from client

	// reply
	double				senttime;
	float				ping_time;
	packet_entities_t	entities;
} client_frame_t;

typedef struct client_s
{
	qboolean active;    // false = client is free
	qboolean spawned;   // client is fully in game (false = don't send datagrams)
	qboolean connected; // has been assigned to a client_t, but not in game yet
	qboolean drop;      // has been told to go to another level
	
	//int lossage; // loss percentage

	qboolean sendinfo; // at end of frame, send info to all
	                   // this prevents malicious multiple broadcasts

	int userid;                     // identifying number
	char userinfo[MAX_INFO_STRING]; // infostring
	
	char physinfo[MAX_INFO_STRING]; // physics info string
	
	usercmd_t lastcmd; // for filling in big drops and partial predictions
	double localtime;  // of last message

	edict_t *edict; // EDICT_NUM(clientnum+1)
	char name[32];  // for printing to other people (extracted from userinfo)
	
	int topcolor;
	int bottomcolor;
	
	client_frame_t frames[UPDATE_BACKUP]; // updates can be deltad from here

	float ping_times[NUM_PING_TIMES];
	int num_pings; // ping_times[num_pings%NUM_PING_TIMES]

	// the datagram is written to after every frame, but only cleared
	// when it is sent out to the client.  overflow is tolerated.
	sizebuf_t datagram;
	byte datagram_buf[MAX_DATAGRAM];

	double connection_started; // or time of disconnect for zombies
	qboolean send_message;     // set on frames a datagram arived on

	// spawn parms are carried from level to level
	float spawn_parms[NUM_SPAWN_PARMS];

	// client known data for deltas
	int old_frags;

	//===== NETWORK ============
	int chokecount;
	int delta_sequence; // -1 = no compression
	netchan_t netchan;
} client_t;

//=============================================================================

#define SPAWNFLAG_NOT_EASY 256
#define SPAWNFLAG_NOT_MEDIUM 512
#define SPAWNFLAG_NOT_HARD 1024
#define SPAWNFLAG_NOT_DEATHMATCH 2048

#ifdef QUAKE2
// server flags
#define SFL_EPISODE_1 1
#define SFL_EPISODE_2 2
#define SFL_EPISODE_3 4
#define SFL_EPISODE_4 8
#define SFL_NEW_UNIT 16
#define SFL_NEW_EPISODE 32
#define SFL_CROSS_TRIGGERS 65280
#endif

//============================================================================

extern cvar_t teamplay;
extern cvar_t skill;
extern cvar_t deathmatch;
extern cvar_t coop;
extern cvar_t fraglimit;
extern cvar_t timelimit;

extern cvar_t servercfgfile;
extern cvar_t lservercfgfile;

extern server_static_t svs; // persistant server info
extern server_t sv;         // local server

extern client_t *host_client;

extern jmp_buf host_abortserver;

extern double host_time;

extern edict_t *sv_player;

extern char outputbuf[8000];

typedef enum
{
	RD_NONE,
	RD_CLIENT,
	RD_PACKET
} redirect_t;

extern redirect_t sv_redirected;

//===========================================================

//
// sv_main.c
//
void SV_Init();

void SV_Frame();

//
// sv_phys.c
//
void SV_Physics();
qboolean SV_RunThink(edict_t *ent);

void SV_StartParticle(vec3_t org, vec3_t dir, int color, int count);
void SV_StartSound(edict_t *entity, int channel, const char *sample, int volume, float attenuation, int pitch);

void SV_DropClient(client_t *drop, qboolean crash, char *fmt, ...);

void SV_SendClientMessages();
void SV_ClearDatagram();

int SV_ModelIndex(const char *name);

void SV_SetIdealPitch();

void SV_AddUpdates();

void SV_ClientThink();

void SV_ClientPrintf(client_t *cl, /*int level,*/ const char *fmt, ...);
void SV_BroadcastPrintf(/*int level,*/ const char *fmt, ...);

void SV_BroadcastCommand(const char *fmt, ...);

qboolean SV_CheckBottom(edict_t *ent);
qboolean SV_movestep(edict_t *ent, vec3_t move, qboolean relink);

void SV_WriteClientdataToMessage(edict_t *ent, sizebuf_t *msg);

void SV_MoveToGoal(edict_t *ent, float dist);

void SV_SaveSpawnparms();

void SV_SpawnServer(const char *server, const char *startspot);

//
// sv_main
//

void SV_ExecuteClientMessage(client_t *cl);

void SV_BeginRedirect(redirect_t rd);
void SV_EndRedirect();

void SV_ActivateServer();
void SV_DeactivateServer();

//

void SV_SetMoveVars();

void SV_UserinfoChanged(client_t *cl);

void SV_ConnectClient();

void SV_SendServerinfo(client_t *cl);
void SV_SendExtraServerinfo(client_t *cl);

void SV_ConnectionlessPacket();

void SV_New_f();